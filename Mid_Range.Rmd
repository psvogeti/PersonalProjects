---
title: "NBA and the Mid-Range"
author: "Pranav Vogeti"
date: "2024-01-07"
output: 
  html_document:
    css: customOutputScript.css
    toc: true
    toc_float: true
---

```{r message = FALSE, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
library(tidyverse)
library(lubridate)
library(kableExtra)
library(sportyR)
```


# Introduction

As we inch closer to the NBA All-Star Game, a game of absent defense and HIGH scoring offense, I was interested in analyzing how the Mid-Range shot in the NBA has evolved over time.


### The Focus Question

How has the mid-range shot in the NBA changed over time, and are there any influences that have mediated this particular shot's volume?

### Motivation

There are many different types of offensive plays in the NBA. Some plays are designed for guards to drive the ball into the basket. Some plays are designed for a quick three point shot. Some plays are designed to wear out the defense before making a decision on what shot to take. 

There are different types of shots in an NBA game. The dunk, the layup, paint shots, the free throw, the three point shot, and the focus of this report: the mid-range. In the early years of the modern NBA (80s-90s), the three point shot was more or less a privilege and an advantage for the undersized guard. Offenses at that time were largely based on physicality and paint-presence. Not many three point shots were taken and were treated as fall back options. Interestingly, if one were to turn on an NBA game now, that is not the case. Even the NBA's big men have developed a competitve jump shot to add an extra dynamicism to their offensive capabilities. Players like Nikola JokiÄ‡, Karl-Anthony Towns, Brook Lopez, Joel Embiid, and many other counterparts are prime examples of this evolution. In fact, in the 2022 three point contest, it was the big man Karl-Anthony Towns that won the infamous shooting contest! Towns was only the third big man to do so, behind very famous players like Dirk Nowitzki and Kevin Love. [^1]

[^1]: https://sports.yahoo.com/minnesota-timberwolves-center-karl-anthony-towns-wins-nba-all-star-3-point-contest-025319348.html

The three point shot has become so commonplace that it is hard to find plays that use the mid-range. If the league's big men have credible three-point shots, defenses get spread out in the half-court as now every offensive player can get a three over a two. A spread out defense also leaves gaping holes that, when properly accounted for by the offense, allows guards to simply drive the ball to the paint for a layup, or dunk, or a chance at the free-throw line. Thus, it is worth investigating the presence (or lackthereof, potentially) of the mid-range and its relations to the three point shot. 

# Background

### About the Original Data: Play-by-Play

The author that has provided the data for us to use is Vladislav Shufinsky. He has compiled NBA play-by-play data from 1996-2022 and made it open-source on Kaggle to allow us to use it for excursions like this[^2].

[^2]: <https://www.kaggle.com/datasets/brains14482/nba-playbyplay-and-shotdetails-data-19962021/data>

The data set we will use will contain a whole season's log of play-by-play data. In order to see changes over time, we will use the collection available from this data set. This collection spans from the 2016-2017 NBA season to the 2022-2023 NBA season inclusive. While the entire dataset consists of four subdata sets, we will choose to use the data originally sourced from *data.nba.com* This means that we will use the files called "*datanba_YYYY.csv*" where YYYY is the season of choice. So, the 2016-2017 season uses the "*datanba_2016.csv*

### The Key Variables

-   The key variables from the *Play-By-Play* we will use for this excursion:
    -   `cl` the time stamp at which the significant play occurred
    -   `de` the short form description of what the play was
    -   `locX` the x-coordinate location of the `de` play
    -   `locY` the y-coordinate location of the `de` play
    -   `hs` the home team total points at the `cl` moment
    -   `vs` the visiting team total points at the `cl` moment
    -   `PERIOD` the quarter of the game so as to distinct `cl`
    -   `GAME_ID` the numerical identifier of the game being played

### Assumptions and Unusuality

A giant aspect of this report relies on the location data: `locX` and `locY`. The way we define the type of shot performed agrees with the NBA standard. However, there are certainly edge cases where we classify a shot differently when compared to the actual scorekeeper's book. Such edge cases are rare, but can and will happen during this excursion. An example of this case can be found in Game 6 of the 2021 NBA Eastern Conference Finals, when the Bucks played the Nets. In that game, Kevin Durant took a shot that had merits to be a three, but was ruled as a two because of his shoe being on the three point line. We will interpret all shots that show on the marking lines as a two, even if some of them were ruled as a three. 

Another aspect of this report is that we are not necessarily evaluating the player's position. This is more of a holistic look at the shot architecture rather than a case-by-case shot outlook. So, a shot taken at the three point line by a Center will be treated the exact same as that shot taken by a Point Guard. We are just interested in looking at a broad look at shot behavior without delving too much into particulars. 

### Report Intentions

The rest of this report will focus on cleaning the data to fit our needs, and analyzing said data and fostering meaningful observations and conclusions. 


# Analysis

## Data Cleanup

### Getting the Shots

First we load in the data. 
```{r load-data , echo=T}
# read the play by play data. this is an expensive chunk to load so run sparingly
raw_pbp_2016_data <- read.csv("../data/datanba_2016.csv")
raw_pbp_2017_data <- read.csv("../data/datanba_2017.csv")
raw_pbp_2018_data <- read.csv("../data/datanba_2018.csv")
raw_pbp_2019_data <- read.csv("../data/datanba_2019.csv")
raw_pbp_2020_data <- read.csv("../data/datanba_2020.csv")
raw_pbp_2021_data <- read.csv("../data/datanba_2021.csv")
raw_pbp_2022_data <- read.csv("../data/datanba_2022.csv")

##print the first 15 rows of a sample of this raw data
head(raw_pbp_2022_data, n=15)
```

Now, we will create our cleaned data sets. Since we are dealing with the same type of data, it makes sense to create a function called `get_shots_data()` that will do this for us. 

```{r get-shot-data-function, echo=T}
##the last name of the player, since that is what is in the pbp data
player_regex = "\\]\\s\\w+"
##to capture all "shot" from the play description
shot_literal = "shot"
##to capture all "3pt" shots from the play description
three_shot_literal = "3pt"
##to capture the team code
team_regex = "\\[[A-Z]{3}"
##to capture all "made" shots from the play description
made_literal = "Made"
##to capture all "missed" shots from the play description
missed_literal = "Missed"

get_shots_data <- function(raw_pbp_data, reg_season) {

  ##get the variables we use
  pbp_data <- raw_pbp_data %>% select(
    GAME_ID, PERIOD, cl, de, locX, locY, hs, vs
  )
  
  ##get the shot data
  shots_data <- pbp_data %>% 
    filter(str_detect(de, pattern=shot_literal) | str_detect(de, pattern=three_shot_literal)) %>%
    group_by(GAME_ID) %>%
    ## responsible for getting the teams involved in this game
    mutate(
      team = str_extract(de, regex(team_regex, FALSE)),
      player_team = substring(team, 2, 5), 
    ) %>%
    ##responsible for getting the player shooting the shot
    mutate(
      player_identifier = str_extract(de, regex(player_regex, TRUE)), 
      player_shooting = substring(player_identifier, 3, last = 1000000L)
    ) %>% 
    ##responsible for classifying certain stage of the game in period.int format
    mutate(
      interval = case_when(
        cl <= "03:00" ~ 0.4, 
        cl <= "06:00" ~ 0.3, 
        cl <= "09:00" ~ 0.2,
        cl <= "12:00" ~ 0.1), 
      stage_of_game = PERIOD + interval 
    ) %>% 
    mutate(
      shot_result = case_when(
        str_detect(string=de, pattern=made_literal) ~ "Made",
        str_detect(string=de, pattern=missed_literal) ~ "Missed"
      )
    ) %>%
    ##QoL change
    rename(gm_quarter = PERIOD) %>%
    ##add the season classifier
    mutate(season = reg_season) %>% ungroup() %>%
    select(season, gm_quarter, stage_of_game, de, player_shooting, player_team, shot_result, locX, locY)
  
  return (shots_data)
}
```

Now we use `get_shots_data()` to get our cleaner shot data for each data set. Note, we are not done cleaning after this, but it is a nice intermediate step to have so that we can avoid running our ` r load_data` chunk. 

```{r get-shots-data, echo=T}
##get the shots taken for the 2021-2022 NBA season
inter_shots_2023 <- get_shots_data(raw_pbp_data = raw_pbp_2022_data, "2022-2023")

##get the shots taken for the 2021-2022 NBA season
inter_shots_2022 <- get_shots_data(raw_pbp_data = raw_pbp_2021_data, "2021-2022")

##get the shots taken for the 2020-2021 NBA season
inter_shots_2021 <- get_shots_data(raw_pbp_data = raw_pbp_2020_data, "2020-2021")

##get the shots taken for the 2019-2020 NBA season
inter_shots_2020 <- get_shots_data(raw_pbp_data = raw_pbp_2019_data, "2019-2020")

##get the shots taken for the 2018-2019 NBA season
inter_shots_2019 <- get_shots_data(raw_pbp_data = raw_pbp_2018_data, "2018-2019")

##get the shots taken for the 2017-2018 NBA season
inter_shots_2018 <- get_shots_data(raw_pbp_data = raw_pbp_2017_data, "2017-2018")

##get the shots taken for the 2016-2017 NBA season
inter_shots_2017 <- get_shots_data(raw_pbp_data = raw_pbp_2016_data, "2016-2017")

##print out a sample of what these data frames look like
head(inter_shots_2017, n=10)
```

```{r combine-shot-data, echo=T}
all_shots_data <- rbind(inter_shots_2017, inter_shots_2018, inter_shots_2019, inter_shots_2020, inter_shots_2021, inter_shots_2022, inter_shots_2023)
```


### Understanding Location Data: $N$

Now that we have all of our shots, it's time to classify each shot. Before we do, we need to understand what `locX` and `locY` are all about. 

`locX` and `locY` are the standard media coordinates used by the NBA teams to locate where a player is with reference to the basketball court. The caveat to this system is that these coordinates represent an NBA-regulation half-court plane. 

For reference, let $x_n$ represent `locX` and $y_n$ represent `locY` such that a player's position $p_n$ on the half-court at any given moment is $p_n = (x_n, y_n)$. The origin of this system is directly underneath the basket. We define this origin as $o_n$ with $o_n = (0, 0)$. 

Let's visualize this through some plotting. We do this in a rather fun way: we will create a function called `graph_player_shots()` that will take in a `player` and a `reg_season` and plot all shots with respect to those parameters. 

```{r plotting-on-N, echo=T}
graph_player_shots <- function(player_name, reg_season) {
  
  ##get the shot data of the player and the season
  player_shots_data <- all_shots_data %>% 
    filter((player_shooting == player_name) & (season == reg_season))
  
  ##generate a plot of this shot data
  player_shot_plot <- ggplot(data = player_shots_data, aes(x=locX, y=locY, color=shot_result)) +
    geom_point(size = 2, alpha = 0.75)  + 
    ylim(-100, 900) + 
    scale_color_manual(values = c("green", "red"), labels = c("Made", "Miss")) +
    xlab("X-Coordinate Location") + 
    ylab("Y-Coordinate Location") +
    ggtitle(paste(player_name, "'s Shot Location Data"), 
            subtitle = paste(reg_season, "NBA Regular Season")) +
    theme_dark()
  
  ##return this plot
  return (player_shot_plot)
}


##graph Lowry's shots in the 2016-2017 NBA regular season
graph_player_shots(player_name = "Lowry", reg_season = "2016-2017")

##graph Brunson's shots in the 2020-2021 nba regular season
graph_player_shots(player_name = "Brunson", reg_season = "2020-2021")

##graph Lillard's shots in the 2021-2022 nba regular season
graph_player_shots(player_name = "Lillard", reg_season = "2021-2022")

```

Through the above plots, we can see not only every specific shot each player took, but also colored based on whether they made it or not. However, one noticeable problem is standardization. Following our convention, all of these are examples of $p_n$ on $N$, However, the $x_n$ and $y_n$ (recall, $p_n= (x_n, y_n)$) scales are not the same. This something we have to fix, by using a package called `sportyR`. Using this package, we can standardize our $p_n$ to `sportyR`'s coordinate-system making it easy to classify our shots.  

Before we leave this section, let's visualize the numeric bounds of $N$. We will do this by picking one season, the 2021-2022 regular season, and examining what the shot spread looks like. 

```{r defining-N, echo=T}
##boundaries of locX and locY which defines N
maxX_N = max(inter_shots_2022$locX)
minX_N = min(inter_shots_2022$locX)
maxY_N = max(inter_shots_2022$locY)
minY_N = min(inter_shots_2022$locY)

originX.N = 0
originY.N = 0

##coordinate labels
left_top_N_text = paste("(",minX_N, ",", maxY_N, ")")
right_top_N_text = paste("(", maxX_N, ",", maxY_N, ")")
left_bottom_N_text = paste("(", minX_N, ",", minY_N, ")")
right_bottom_N_text = paste("(", maxX_N, ",", minY_N, ")")
origin_N_text = paste("(", originX.N, ",", originY.N, ")")

## plot our boundaries
ggplot() + 
  geom_point(aes(x=maxX_N,y=maxY_N), colour = "red", size = 4) + 
  geom_point(aes(x=maxX_N,y=minY_N), colour = "red", size = 4) +
  geom_point(aes(x=minX_N,y=maxY_N), colour = "red", size = 4) +
  geom_point(aes(x=minX_N,y=minY_N), colour = "red", size = 4) +
  geom_point(data = inter_shots_2022, aes(x=locX, y=locY),  colour = "green", size = .8, alpha = .5) +
  geom_point(aes(x= originX.N, y=originY.N), colour = "blue", size = 4) +
  xlab("X-Coordinate Range") +
  ylab("Y-Coordinate Range") +
  ggtitle("Defining the NBA Location Data Coordinate System", subtitle = "2022-2023 NBA Regular Season") +
  theme_dark()
```

The points signify these boundary markers: 

  * Our top left red point has coordinates: `r left_top_N_text[1]` and is the most extreme shot taken in this quadrant
  * Our top right red point has coordinates: `r right_top_N_text[1]` and is the most extreme shot taken in this quadrant
  * Our bottom left red point has coordinates: `r left_bottom_N_text[1]` and is the most extreme shot taken in this quadrant
  * Our bottom right red point has coordinates: `r right_bottom_N_text[1]` and is the most extreme shot taken in this quadrant
  * The blue point signifies our origin $o_n$ with coordinates: `r origin_N_text[1]`
  
  
To define N, we need to do some math. 

We know that the standard NBA court has dimensions (width by length) $94\text{ft X } 50\text{ft}$
Therefore, the coordinates have to be some scaled version of these dimensions to retain the mapping properties of the shots.

So, to know what that numerical proportion is, we need to take the range of our plotted length and divide it by the standard length ($50\text{ ft}$). We can then apply this proportion to find our plotted width. 

```{r N-dimensions, echo=TRUE}
## dimensions of a standard court
STANDARD_CT_LENGTH = 50
STANDARD_CT_WIDTH = 94

## the length of N
LENGTH.N = abs(maxX_N - minX_N)

## find the proportion at which the standard court was scaled
prop_scaled = LENGTH.N / STANDARD_CT_LENGTH

## use this proportion to get our width  
WIDTH.N = STANDARD_CT_WIDTH * prop_scaled

## intervals of x_n and y_n
LOW_N.X = minX_N
HIGH_N.X = LOW_N.X + LENGTH.N
LOW_N.Y = minY_N
HIGH_N.Y = minY_N + WIDTH.N
```
  
  


From this chunk we know the following: 
For `locX` ($x_n$) and `locY` ($y_n$), with respect to a player's position $p_n = (x_n, y_n)$ on the basketball court plane $N$, we define $N$ as follows: 

$$
N = \{p_n = (x_n,y_n) \mid x_n \in [`r LOW_N.X[1]`, `r HIGH_N.X[1]`], y_n \in [`r LOW_N.Y[1]`, `r HIGH_N.Y[1]`]\}
$$

This can be read as: 

> The court system that the NBA uses for shot-plotting (call it $N$), is simply the whole collection of all possible player positions $p_n$ where $p_n$ is simply a point on $N$ defined by the player's x-coordinate on $N$ (called $x_n$) and the player's y-coordinate on $N$ (called $y_n$) to give us $p_n = (x_n, y_n)$. The interval $x_n \in [`r LOW_N.X[1]`, `r HIGH_N.X[1]`]$ defines all possiblilities that $x_n$ can be on this court $N$. Similarly, the interval $y_n \in [`r LOW_N.Y[1]`, `r HIGH_N.Y[1]`]$ defines all possiblilities that $y_n$ can be on this court $N$.


### Understanding Location Data: $R$


As we did for our location data, we defined a coordinate system that we called $N$. Now, let's define a coordinate system for `sportyR`

Additionally, let $x_r$ represent the traditional x coordinate in the basketball court plane that `sportyR` uses for its graphs. Consequently, let $y_r$ represent the traditional y coordinate in the basketball court plane that `R` uses for its graphs. Then, with respect to any traditional basketball court that `sportyR` uses, we define a position $p_r$ as the generalized location of any point on these basketball courts that `sportyR` uses such that $p_r = (x_r, y_r)$. Naturally, this means $p_r$ has origin $o_r = (0, 0)$ which we will establish in the upcoming visualizations. 

Let's visualize $R$

```{r basketball-court-visualization, echo=T}
#court parameters/selectors
LEAGUE = "NBA"
COURT_VIEWS = c( "full", "offense", "offensive_key")
DEG_ROTATE = -90

##generate an NBA regulation offensive-half-court
basketball_court <- geom_basketball(league = LEAGUE, display_range = COURT_VIEWS[1], rotation = DEG_ROTATE)

basketball_court
```

Let's go ahead and identify our boundaries. Since we know all of our shots must be inside the court perimeter, it makes sense to exclude the out-of-bounds region when defining our boundaries. We also know that an NBA court has regulation dimensions: 94 ft X 50 ft. Since, we are dealing with the half-court perimeter, proportionately the half-court has dimensions 47 ft X 50 ft. 

```{r court-boundaries, echo=T}
##boundary constants
LEFT_LINE = -25
RIGHT_LINE = 25
TOP_LINE = 47
BOTTOM_LINE = -47
originX.R = 0
originY.R = 0

##coordinate labels
left_top_coord_text = paste("(", LEFT_LINE, ",", TOP_LINE, ")")
right_top_coord_text = paste("(", RIGHT_LINE, ",", TOP_LINE, ")")
left_bottom_coord_text = paste("(", LEFT_LINE, ",", BOTTOM_LINE, ")")
right_bottom_coord_text = paste("(", RIGHT_LINE, ",", BOTTOM_LINE, ")")
origin_coord_text = paste("(", originX.R, ",", originY.R, ")")

##plot the boundaries
half_court_boundaries <- basketball_court +
  geom_hline(yintercept = TOP_LINE, color = "navyblue", linewidth = 2) +
  geom_hline(yintercept = BOTTOM_LINE, color = "steelblue", linewidth = 2) +
  geom_vline(xintercept = LEFT_LINE, color = "maroon", linewidth = 2) +
  geom_vline(xintercept = RIGHT_LINE, color = "red", linewidth = 2) + 
  geom_point(aes(x=LEFT_LINE, y=TOP_LINE), colour="limegreen", size = 4) + 
  geom_point(aes(x=RIGHT_LINE, y=TOP_LINE), colour="limegreen", size = 4) +
  geom_point(aes(x=LEFT_LINE, y=BOTTOM_LINE), colour="limegreen", size = 4) +
  geom_point(aes(x=RIGHT_LINE, y=BOTTOM_LINE), colour="limegreen", size = 4) +
  geom_point(aes(x=originX.R, y = originY.R), colour = "black", size = 4)
  

## visualize the boundaries
half_court_boundaries
```

Let's quickly discuss what we see. 
The navy blue line is our top border with $y_r = `r TOP_LINE[1]`$.
The steel blue line is our bottom border with $y_r = `r BOTTOM_LINE[1]`$. 
The maroon line is our left border with $x_r = `r LEFT_LINE[1]`$. 
The red line is our right border with $x_r = `r RIGHT_LINE[1]`$. 

The green points signify these line intersections: 

  * Our top left green point has coordinates: `r left_top_coord_text[1]`
  * Our top right green point has coordinates: `r right_top_coord_text[1]`
  * Our bottom left green point has coordinates: `r left_bottom_coord_text[1]`
  * Our bottom right green point has coordinates: `r right_bottom_coord_text[1]`
  
The black point is our origin $o_r$ with coordinates: `r origin_coord_text[1]`


We can now define $R$ more rigorously. For any position $p_r$ that is in $R$, we have that: 

$$
R = \{p_r = (x_r,y_r) \mid 
      x_r \in [`r LEFT_LINE[1]`, `r RIGHT_LINE[1]`], y_r \in [`r BOTTOM_LINE[1]`, `r TOP_LINE[1]`]
\}
$$
This can be read as: 

> The court system that `sportyR` uses for shot-plotting (call it $R$), is simply the whole collection of all possible player positions $p_r$ where $p_r$ is simply a point on $R$ defined by the player's x-coordinate on $R$ (called $x_r$) and the player's y-coordinate on $R$ (called $y_r$) to give us $p_r = (x_r, y_r)$. The interval 
$x_r \in [`r LEFT_LINE[1]`, `r RIGHT_LINE[1]`]$ defines all possiblilities that $x_r$ can be on this court $R$. Similarly, the interval $y_r \in [`r BOTTOM_LINE[1]`, `r TOP_LINE[1]`]$ defines all possiblilities that $y_r$ can be on this court $R$.


### Going from $N$ to $R$ to get $C$. 

Now, we have established two coordinate systems: 

$N$, which is the coordinate system that our data inherently uses, is defined as: 

$$
N = \{p_n = (x_n,y_n) \mid x_n \in [`r LOW_N.X[1]`, `r HIGH_N.X[1]`], y_n \in [`r LOW_N.Y[1]`, `r HIGH_N.Y[1]`]\}
$$

$R$, which is the coordinate system that `sportyR` uses, is defined as: 

$$
R = \{p_r = (x_r,y_r) \mid 
      x_r \in [`r LEFT_LINE[1]`, `r RIGHT_LINE[1]`], y_r \in [`r BOTTOM_LINE[1]`, `r TOP_LINE[1]`]
\}
$$
To draw attention to our goal, the end goal is to standardize our location data so that we can, under one coordinate system $C$, define what each shot based on the precision of our location data. This will remove any ambiguity on how we define two point shots. Thus, we need to define our new origin $o$ that will be the foundation point that $C$ uses.

Mathematically, we make a general statement that will be more rigorously defined later: 

For standardized $x$ location and standardized $y$ location of a player's position $p$ where $p = (x, y)$), let our final coordinate system $C$ be defined as follows:  

$$
C = \{p = (x,y) \mid x \in \mathbb{R}, y \in \mathbb{R}\}
$$

So, we need to make `locX` ($x_n$) and `loc_y`($y_n$) usable so that we can plot these points $p_n$ on `sportyR`'s court $R$. This will take several translations, hence why we will go through the effort to define one more, final coordinate system that has everything standardized. We call this coordinate system $C$. To get $C$, there are three major steps we need to take: 

    1) Translate $o_n$ to $o_r$, giving us a new origin $o$
    2) Translate $R$ to scale under it's new origin $o$
    3) Define final court coordinate system $C$ under the geometric transitions


#### Translating $o_r$ to $o_n$ to get $o$

To see how far we need to translate $o_n$ to $o_r$, let's first plot $o_n$ on $R$. From [Understanding Location Data: $N$], we know that $o_n$ lies underneath the basket on the TV offensive half-court. 
Let's find what the coordinates of $o_n$ would be then if we plot it underneath the basket of $R$. 

```{r plot-originN-on-R, echo=T}
## tweak these numbers until we find the translation
shift_x = 0
shift_y = -42

## "(x_trans, y_trans)"
shifted_origin_text = paste("(", shift_x, ",", shift_y, ")")


half_court_boundaries +
  geom_point(aes(x=shift_x, y=shift_y), colour="yellow", size = 4) 
```

What does this visualization tell us? First, this is a rotated view of $R$ (-90 deg). Thus, the $+x_r$ and the $+y_r$ axis have been rotated (-90 deg) as well. This means that $+x_r$ points to East of our black dot, and $+y_r$ points North of our black dot, with our black dot representing the origin of $R$, $o_r$. So, to make our new origin $o$, we need to shift $o_r$ downwards ($-y_r$) by `r shift_y[1]` units on this rotated view of $R$. This means on the standard (0 deg) view of $R$, we actually make a rightwards translation in the $+x_r$ direction. 


#### Using $o$ to redefine $R$

Let's define a new basketball court with these shifts in mind

```{r translate-geometries, echo=T}
originX = 0
originY = 0

##new court, rotated -90, so really we need to make an x-translation equivalent to our y-translation from the previous court plot since the x_trans argument translates our axis for a non-rotated basketball court. 
new_court <- geom_basketball(league=LEAGUE, display_range=COURT_VIEWS[1], rotation=DEG_ROTATE,
                             x_trans = shift_y)
##display the new court with our new origin: o
new_court + geom_point(aes(x = originX, y=originY), color = "yellow", size = 4)
```

This has our origin $o$ in yellow with coordinates `r origin_coord_text[1]` that agrees with $o_n$ convention. Now, let's redefine $R$. In doing so, we can scale this new $R$ to agree with $N$ and therefore the resulting coordinate system is our final coordinate system $C$. 

```{r new-court-boundaries, echo=T}
##boundary constants
LEFT_X = -25
RIGHT_X = 25
TOP_Y = 89
BOTTOM_Y = -5

##coordinate labels
left_top_text = paste("(", LEFT_X, ",", TOP_Y, ")")
right_top_text = paste("(", RIGHT_X, ",", TOP_Y, ")")
left_bottom_text = paste("(", LEFT_X, ",", BOTTOM_Y, ")")
right_bottom_text = paste("(", RIGHT_X, ",", BOTTOM_Y, ")")
origin_text = paste("(", originX, ",", originY, ")")

##plot the boundaries
new_court_boundaries <- new_court +
  geom_hline(yintercept = TOP_Y, color = "navyblue", linewidth = 2) +
  geom_hline(yintercept = BOTTOM_Y, color = "steelblue", linewidth = 2) +
  geom_vline(xintercept = LEFT_X, color = "maroon", linewidth = 2) +
  geom_vline(xintercept = RIGHT_X, color = "red", linewidth = 2) + 
  geom_point(aes(x=LEFT_X, y=TOP_Y), colour="limegreen", size = 4) + 
  geom_point(aes(x=RIGHT_X, y=TOP_Y), colour="limegreen", size = 4) +
  geom_point(aes(x=LEFT_X, y=BOTTOM_Y), colour="limegreen", size = 4) +
  geom_point(aes(x=RIGHT_X, y=BOTTOM_Y), colour="limegreen", size = 4) +
  geom_point(aes(x=originX.R, y = originY.R), colour = "black", size = 4)

new_court_boundaries
```

Let's quickly discuss what we see. 
The navy blue line is our top border with $y_r = `r TOP_Y[1]`$.
The steel blue line is our bottom border with $y_r = `r BOTTOM_Y[1]`$. 
The maroon line is our left border with $x_r = `r LEFT_X[1]`$. 
The red line is our right border with $x_r = `r RIGHT_X[1]`$. 

The green points signify these line intersections: 

  * Our top left green point has coordinates: `r left_top_text[1]`
  * Our top right green point has coordinates: `r right_top_text[1]`
  * Our bottom left green point has coordinates: `r left_bottom_text[1]`
  * Our bottom right green point has coordinates: `r right_bottom_text[1]`
  
The black point is our origin $o$ with coordinates: `r origin_text[1]`

```{r R-dimensions, echo=T}
## dimensions of R
LENGTH.R = abs(RIGHT_X - LEFT_X)
WIDTH.R = abs(TOP_Y - BOTTOM_Y)
```


Mathematically, $R$ has been redefined this way: 

$$
R = \{p_r = (x_r,y_r) \mid 
      x_r \in [`r LEFT_X[1]`, `r RIGHT_X[1]`], y_r \in [`r BOTTOM_Y[1]`, `r TOP_Y[1]`]
\}
$$
This can be read as: 

> The court system that `sportyR` uses for shot-plotting (call it $R$), is simply the whole collection of all possible player positions $p_r$ where $p_r$ is simply a point on $R$ defined by the player's x-coordinate on $R$ (called $x_r$) and the player's y-coordinate on $R$ (called $y_r$) to give us $p_r = (x_r, y_r)$. The interval $x_r \in [`r LEFT_X[1]`, `r RIGHT_X[1]`]$ defines all possiblilities that $x_r$ can be on this court $R$. Similarly, the interval $y_r \in [`r BOTTOM_Y[1]`, `r TOP_Y[1]`]$ defines all possiblilities that $y_r$ can be on this court $R$.


#### Defining C

To quickly recap, we have defined a coordinate system called $N$ in [Understanding Location Data: $N$]. We have also defined a separate coordinate system called $R$ in [Understanding Location Data: $R$]. In this section, our aim is to get $C$, a final coordinate system that we can use to classify our shots. 

Since we have $o_n = o_r = `r origin_text[1]`$, all we need to do is apply a set of scalars $k_x, k_y$ to scale $p_r$ to $p_n$. These scaled $p_r * k$ values will then be interpreted as our possible $p$ coordinates for our final coordinate system $C$. 


Now, let's recap our coordinate systems:  

$N$, which is the coordinate system that our data inherently uses, is defined as: 

$$
N = \{p_n = (x_n,y_n) \mid x_n \in [`r LOW_N.X[1]`, `r HIGH_N.X[1]`], y_n \in [`r LOW_N.Y[1]`, `r HIGH_N.Y[1]`]\}
$$

$R$, which is the coordinate system that `sportyR` uses, has been **NEWLY** redefined as: 

$$
R = \{p_r = (x_r,y_r) \mid 
      x_r \in [`r LEFT_X[1]`, `r RIGHT_X[1]`], y_r \in [`r BOTTOM_Y[1]`, `r TOP_Y[1]`]
\}
$$

We define $K$ as the general ratio between these systems: 
$K = \frac{R}{N}$. In this way, we can use our `locX` ($x_n$) and `locY` ($y_n$) data and apply $K$ on those to make them graph-friendly on $C$. 

For $(x_n, y_n) = p_n \in N$  

Coordinate system $C$ is the result of shrinking $N$'s bounds to agree with $R$'s bounds through 
scalar $K = \{k_x, k_y\}$

$$
C = \{p = (x, y) \mid x = \frac{x_n}{k_x}, y = \frac{y_n}{k_y}\}
$$
For $k_x, k_y \in K$


Let's now implement $K$!

```{r scalar-K, echo=T}
## K = dim(R)/dim(N)
K.x = LENGTH.R/LENGTH.N
K.y = WIDTH.R/WIDTH.N

## Translate our N coordinate system to the R coordinate system by K
## This gives us a new set of coordinates that we call C (our final system)
## P_n * (K = {R/N}) = P_r --> P_c
all_shots_data <- all_shots_data %>%
  mutate(c.x = locX * K.x, 
         c.y = locY * K.y)
```

```{r C-bounds, echo=T}
##boundaries of c.x and c.y which defines C
maxX_C = max(all_shots_data$c.x)
minX_C = min(all_shots_data$c.x)
maxY_C = max(all_shots_data$c.y)
minY_C = min(all_shots_data$c.y)
```

Having added all of our new $p$ to the data set, we have the following mathematical definition for $C$.

$$
C = \{p = (x,y) \mid 
      x \in [`r minX_C[1]`, `r maxX_C[1]`], y_r \in [`r minY_C[1]`, `r maxY_C[1]`]
\}
$$
This can be read as: 

> The final court system that we use for shot-plotting (call it $C$), is simply the whole collection of all possible player positions $p$ where $p$ is simply a point on $C$ defined by the player's x-coordinate on $C$ (called $x$) and the player's y-coordinate on $C$ (called $y$) to give us $p = (x, y)$. The interval 
$x \in [`r minX_C[1]`, `r maxX_C[1]`]$ defines all possiblilities that $x$ can be on this court $C$. Similarly, the interval $y \in [`r minY_C[1]`, `r maxY_C[1]`]$ defines all possiblilities that $y$ can be on this court $C$.

```{r final-court, echo=T}
final_court <- geom_basketball(league=LEAGUE, display_range=COURT_VIEWS[2], rotation=DEG_ROTATE,
                             x_trans = shift_y)
```


### Classifying our Shots

Here is the crux of our data cleanup: classifying our shots. To justify $C$, let's create a function that is very similar to `graph_player_shots()`, with the only change being we use `c.x` and `c.y` instead of `locX` and `locY`

```{r graph-standardized-shots, echo=T}
graph_standardized_shots <- function(player_name, reg_season) {
  
  ##get the shot data of the player and the season
  player_shots_data <- all_shots_data %>% 
    filter((player_shooting == player_name) & (season == reg_season))
  
  ##generate a plot of this shot data using (x,y) E C
  player_shot_plot <- final_court +
    geom_point(data = player_shots_data, aes(x=c.x, y=c.y, color=shot_result)) +
    geom_point(size = 1, alpha = 0.75)  + 
    scale_color_manual(aesthetics = "color", values=c("darkolivegreen","firebrick4"), labels = c("Made","Missed")) +
    xlab("X-Coordinate Location") + 
    ylab("Y-Coordinate Location") +
    ggtitle(paste(player_name, "'s Shot Location Data"), 
            subtitle = paste(reg_season, "NBA Regular Season"))
  
  ##return this plot
  return (player_shot_plot)
}


##graph Lowry's shots in the 2016-2017 NBA regular season
graph_standardized_shots(player_name = "Lowry", reg_season = "2016-2017")

##graph Brunson's shots in the 2020-2021 nba regular season
graph_standardized_shots(player_name = "Brunson", reg_season = "2020-2021")

##graph Lillard's shots in the 2021-2022 nba regular season
graph_standardized_shots(player_name = "Lillard", reg_season = "2021-2022")
```

That is a much better visual then what we dealt with before. With this, we can clearly see where each player took their shot and what the result was. Much can be improved with this plot, but at least we have this cleaner plot, using our final coordinate system $C$. 

One last step remains to classify our shots!

We know that our `de` in `all_shots_data` informs us on if the shot taken was a three point shot. If it is, we call it a `"THREE POINTER"` shot. Otherwise, the shot is indeed a two-point shot. Then we have two cases. The first case is that the two-point-shot is taken in the paint. If so, we simply describe this shot as a `"PAINT"` shot. If it is not in the paint, and it is a two-point shot, then it must be a `"MID RANGE"` shot.

It is clear then that we must define the `"PAINT"` region. Let's call this region $P$, following the same exact structure as $N$, $R$, and $C$. The only difference is that $P$ is a region inside of $C$ instead of being its own coordinate system: 

Generally, we say that: 

Given
$$
P \subseteq C
$$

Let 
$$
P = \{p_p = (x_p,y_p) \mid 
      x_p \in \mathbb{R}, y_p \in \mathbb{R}
\}
$$

This can be read as: 

> We define the paint region as $P$ and exists inside of $C$. $P$ is simply the whole collection of all possible player positions $p_p$ where $p_p$ is simply a point inside $P$ defined by the player's x-coordinate in $P$ (called $x_p$) and the player's y-coordinate in $P$ (called $y_p$) to give us $p_p = (x_p, y_p)$. The interval is not yet strictly defined. 

Let's visualize $P$
```{r defining-P, echo=T}
##boundary constants
PAINT_MIN.X = -8
PAINT_MAX.X = 8
PAINT_MIN.Y = -5
PAINT_MAX.Y = 14

##coordinate labels
left_top_paint_text = paste("(", PAINT_MIN.X, ",", PAINT_MAX.Y, ")")
right_top_paint_text = paste("(", PAINT_MIN.X, ",", PAINT_MAX.Y, ")")
left_bottom_paint_text = paste("(", PAINT_MIN.X, ",", PAINT_MIN.Y, ")")
right_bottom_paint_text = paste("(", PAINT_MAX.X, ",", PAINT_MIN.Y, ")")

##plot the boundaries
paint_boundaries <- final_court +
  geom_hline(yintercept = PAINT_MAX.Y, color = "navyblue", linewidth = 2) +
  geom_hline(yintercept = PAINT_MIN.Y, color = "steelblue", linewidth = 2) +
  geom_vline(xintercept = PAINT_MIN.X, color = "maroon", linewidth = 2) +
  geom_vline(xintercept = PAINT_MAX.X, color = "red", linewidth = 2) + 
  geom_point(aes(x=PAINT_MIN.X, y=PAINT_MAX.Y), colour="limegreen", size = 4) + 
  geom_point(aes(x=PAINT_MAX.X, y=PAINT_MAX.Y), colour="limegreen", size = 4) +
  geom_point(aes(x=PAINT_MIN.X, y=PAINT_MIN.Y), colour="limegreen", size = 4) +
  geom_point(aes(x=PAINT_MAX.X, y=PAINT_MIN.Y), colour="limegreen", size = 4)

paint_boundaries
```

Let's quickly discuss what we see. 
The navy blue line is our top border of $P$ with $y_p = `r PAINT_MAX.Y[1]`$.
The steel blue line is our bottom border of $P$  with $y_p = `r PAINT_MIN.Y[1]`$. 
The maroon line is our left border of $P$ with  $x_p = `r PAINT_MIN.X[1]`$. 
The red line is our right border of $P$ with $x_p = `r PAINT_MAX.X[1]`$. 

The green points signify these line intersections: 

  * Our top left green point has coordinates: `r left_top_paint_text[1]`
  * Our top right green point has coordinates: `r right_top_paint_text[1]`
  * Our bottom left green point has coordinates: `r left_bottom_paint_text[1]`
  * Our bottom right green point has coordinates: `r right_bottom_paint_text[1]`
  
  
Mathematically, $P$ has been redefined this way: 


Given
$$
P \subseteq C
$$

Strictly we can say, 
$$
P = \{p_p = (x_p,y_p) \mid 
      x_p \in [`r PAINT_MIN.X[1]`, `r PAINT_MAX.X[1]`], y_p \in [`r PAINT_MIN.Y[1]`, `r PAINT_MAX.Y[1]`]
\}
$$  
The setup is complete. Let's classify our shots in the variable `shot_type`! 
In this chunk, we will also add `shot_distance` to quantify how far each shot is from the basket. 

```{r classify-shots, echo=T}
##function to see if our c.x and c.y are in P
is_paint_shot <- function(x_coord, y_coord) {
  
  ##check the x and y intervals
  paint_shot = (x_coord <= PAINT_MAX.X & x_coord >= PAINT_MIN.X) &
               (y_coord <= PAINT_MAX.Y & y_coord >= PAINT_MIN.Y)
  
    ##return the result  
    return(paint_shot)
}

##function to get shot_distance
get_shot_distance <- function(x_coord, y_coord) {
  
  ##check the x and y intervals
  shot_distance= sqrt((x_coord * x_coord) + (y_coord * y_coord))
  
    ##return the result  
    return(shot_distance)
}

## get our final data
final_shots_data <- all_shots_data %>%
  mutate(
    ##three or paint
    paint_shot = is_paint_shot(x_coord = c.x, y_coord = c.y), 
    three_shot = str_detect(string=de, pattern=three_shot_literal)
  ) %>%
  mutate(
    ##paint, if not paint then check three, if not three, then it is midrange
    shot_type = case_when(
      paint_shot ~ "PAINT SHOT",
      three_shot ~ "THREE POINTER",
      TRUE ~ "MID RANGE"
    )
  ) %>%
  mutate(
    ##calculate the shot distances
    shot_distance = get_shot_distance(x_coord = c.x, y_coord = c.y)
  ) %>%
  select(season, gm_quarter, stage_of_game, de, player_shooting, c.x, c.y, shot_type, shot_result, shot_distance)
```

Let's test our classification system. Again, we simply create a function that colors the shot for a given player and a given season. 

```{r graph-classfied-shots, echo=T}
graph_classified_shots <- function(player_name, reg_season) {
  
  ##get the shot data of the player and the season
  player_shots_data <- final_shots_data %>% 
    filter((player_shooting == player_name) & (season == reg_season))
  
  ##generate a plot of this shot data using (x,y) E C
  player_shot_plot <- final_court +
    geom_point(data = player_shots_data, aes(x=c.x, y=c.y, color=shot_type)) +
    geom_point(size = 1, alpha = 0.75)  + 
    scale_color_manual(aesthetics = "color", 
                       values=c("navy","cyan3", "darkgoldenrod1"), 
                       labels = c("Mid-Range", "Paint", "Three")) + 
    xlab("X-Coordinate Location") + 
    ylab("Y-Coordinate Location") +
    ggtitle(paste(player_name, "'s Shot Location Data"), 
            subtitle = paste(reg_season, "NBA Regular Season"))
  
  ##return this plot
  return (player_shot_plot)
}

##graph Lowry's shots in the 2016-2017 NBA regular season
graph_classified_shots(player_name = "Lowry", reg_season = "2016-2017")

##graph Brunson's shots in the 2020-2021 nba regular season
graph_classified_shots(player_name = "Brunson", reg_season = "2020-2021")

##graph Lillard's shots in the 2021-2022 nba regular season
graph_classified_shots(player_name = "Lillard", reg_season = "2021-2022")
```

Phew! That concludes the massive data cleanup process! Now, we have everything we need to begin our analysis of [The Focus Question]

### Analysis: Mid-Range Over Time 

Let's analyze the prevalence of the mid-range shot over time. This analysis can provide us with a context for how the game has evolved with relation to its counterpart shots. 

```{r shots-time-data, echo = T}
##get the counts of each shot by season
shots_by_season <- final_shots_data %>%
  group_by(season, shot_type) %>%
  summarize(num_shots = n())
```

```{r shots-time-graph, echo = T}
ggplot(shots_by_season, aes(x = season, y=num_shots, color=shot_type, group = shot_type)) +
  geom_point(size = 4) +
  geom_line(linewidth = 1.5) +
  scale_color_manual(aesthetics = "color", 
                       values=c("navy","cyan3", "darkgoldenrod1"), 
                       labels = c("Mid-Range", "Paint", "Three")) + 
  guides(color = guide_legend(title = "Shot Type")) + 
  xlab("NBA Regular Season") +
  ylab("Number of Shots") +
  ggtitle("NBA Regular Season Shot Selection Over Time", subtitle = "2016-2023") +
  theme_dark() +
  theme(plot.background = element_rect(fill = "papayawhip")) +
  theme(legend.background = element_rect(fill = "papayawhip")) 

```

Unsurprisingly, one glaring takeaway is the sheer prominence of the Three Point Shot over any other shot. Hovering over attempts of 75000, with a general increasing trend during this time frame, it is clear the NBA values this shot. The midrange and the paint look paltry in comparison, hovering well underneath 25000 shot attempts. From this graph we can also conlude one other aspect of the offensive game: there is simply a greater volume of shots. If the shot volume were to be consistent year-over-year, we would expect that a rise in three point shots would equate to a decrease in paint shots and mid-range shots. However, our graph shows that this is not necessarily the case. While we do have a general rising volume of three point shots, the mid-range and paint shots remained rather steady in shot volume, indicating that offenses generally experience more possessions in recent years than past years. 



### Analysis: Shot Volume by Quarter and Stage of Game

Let's take a look at what the shot selection looks like at a finer level. To do this, we will factor in the quarter at which the shot was taken, and the stage within the quarter at which the shot was taken. 


```{r shots-game-data, echo =T}

## get the shots by quarter and stage of the game. 
## we are not concerned about overtime periods
## because we did not define intervals in those periods
shots_in_game <- final_shots_data %>%
  select(season, shot_type, gm_quarter, stage_of_game) %>%
  filter(gm_quarter < 5) %>%
  group_by(season, shot_type, gm_quarter, stage_of_game) %>%
  summarize(num_shots = n())
 

```

```{r shots-game-graph, echo = T}
ggplot(shots_in_game, aes(x=stage_of_game, y=num_shots, color = shot_type, fill = shot_type)) + 
  geom_col() +
  facet_wrap(vars(gm_quarter), scales = "free") + 
  theme_dark() +
  theme(plot.background = element_rect(fill = "papayawhip")) + 
  theme(legend.background = element_rect(fill = "papayawhip")) +
  xlab("Stage of the Game") +
  ylab("Number of Shots") +
  ggtitle("NBA Shot Selection By Quarter and Stage of Game", subtitle = "2016-2023")
```

From this beautiful graph, we can see that regardless of the quarter, the three point shot is the heavy favorite for players. Each quarter has an almost identical bar graph as the other quarters. 


### Analysis: Shot Distance 

Another graph that can provide rich context for [The Focus Question] is how the shot-distance map looks. We can do this through a contour map. If we let our contour map be based on our shot-distances, we can see the frequency of each contour. This gives us a unique way to see not only what shot is popular, but at what range are the players most comfortable in shooting

```{r distance-contour-graph, echo=T}
final_court + 
  geom_contour_filled(data = final_shots_data, 
                      aes(x = c.x, y = c.y, z = shot_distance)) +
  labs(fill = "Shot Distance (ft)") +
  xlab("X-coordinate") +
  ylab("Y-coordinate") +
  ggtitle("Visualizing Shot Selection By Shot Distance (ft)", 
          subtitle = "NBA Regular Seasons 2016-2023") +
  theme_dark() +
  theme(plot.background = element_rect(fill = "papayawhip")) + 
  theme(legend.background = element_rect(fill = "papayawhip"))
```

From this graph, we can not only see shot distribution, but also the activity each region witnesses given our shot distances. It's pretty clear to see that we have a wonderful busy distribution of shots along the three-point line. But between the (20,30] range and the (10, 20] range, there is a noticeable void of empty space. 
This aligns with our intuition because that space has no real value to a shot. The space offers a difficult mid-range shot which, at that point, should just be a three point attempt instead.  


### Analysis: Shot Accuracy

This is a neat metric that assesses the change in accuracy of a player by shot type, year-over-year. In doing so, we can see how our focus player has adapted his shot over time, and what shots he is primarily focusing on. 

```{r accuracy-plot}
graph_player_accuracies <- function(player_name) {
  
##get the shot data of the player
player_shots_data <- final_shots_data %>% 
  filter(player_shooting == player_name)

player_accuracy_data <- player_shots_data %>% 
 group_by(season, shot_type) %>%
 summarize(num_attempts = n(),
           num_made = sum(shot_result == "Made"), 
           shot_pct = num_made/num_attempts)

acc_plot <- ggplot(player_accuracy_data, aes(x=season, y=shot_pct, color = shot_type, group = 1)) + 
  geom_point(size = 4) +
  geom_line(linewidth = 1.5) +
  facet_wrap(vars(shot_type), scales = "fixed") + 
  theme_dark() +
  theme(plot.background = element_rect(fill = "papayawhip")) + 
  theme(legend.background = element_rect(fill = "papayawhip")) +
  labs(color = "Shot Type") +
  guides(x = guide_axis(angle = 90)) +
  xlab("NBA Regular Season") +
  ylab("Shot Accuracy") +
  ggtitle(paste(player_name, "'s Shot Accuracy"), 
            subtitle = "NBA Regular Seasons 2016-2023")

  return(acc_plot)

}

##graph Mykhailiuk's shot accuracies
graph_player_accuracies(player_name = "Mykhailiuk")

##graph Brunson's shot accuracies
graph_player_accuracies(player_name = "Brunson")

##graph Lillard's shot accuracies
graph_player_accuracies(player_name = "Durant")
```

From these graphs, it is nice to see each shot type on its own grid. In this way, clutter is reduced making it easy to horizontally compare the data next to one another. Since this graph varies by player, what we can look for is how the accuracy of each shot type has changed. If particular shot types see a wide range of accuracies, then we can interpret this to mean that the player is not really worried about those shot types. Conversely, if we see a consistent increase or a steady line in shot type accuracy, then we know that the player is concentrating his offense on that shot type. 

Durant is a key example of this style of interpretation. For the mid range and the three pointer shot, his accuracies have been relatively consistent. However, his paint shot has seen noticeable decline before an unprecedented increase between 2020-2021 and 2021-2022. We can interpret these observations to say that he is a perimeter threat that will shoot when he has the chance. If not, the paint is available to him. 


# Discussion

In this section, we will discuss our analysis and also the limitations that we have with regards to this report. In addition, we offer alternative paths to approach [The Focus Question], and discuss the possible extensions to this report. 

### Comparing the Graphs & Overall Conclusions

#### Graph Comparisons Discussion

The result of this report is rather dynamic. In [Analysis: Mid-Range Over Time], [Analysis: Shot Volume by Quarter and Stage of Game] and [Analysis: Shot Distance], we offer summarizing data with respect to the mid range and its counterparts. 

In [Analysis: Mid-Range Over Time], we witnessed an astounding difference in shot volume between the three point shot against its other shot types. 

In [Analysis: Shot Volume by Quarter and Stage of Game], we again saw the shot volume difference at an even smaller scale, by the quarter and the interval within the quarter. Across all quarters, the data demonstrated that players consistently opt for the three point shot more than any other shot in the game. 

In [Analysis: Shot Distance], we saw a striking visual that relayed the densities of shots based on their distance from the basket. The three point shot was the busiest of all shots, while the mid-range was only viable at an intermediate distance between the three and the paint. 

However, the dynamicism is reflected in our `graph_standardized_shots()`, `graph_player_accuracies()` and `graph_classified_shots()`. Each one of these functions offers a way to see, at the player-level, how their shot selection has fared in terms of the shot result (`graph_standardized_shots()`), shot accuracy (`graph_player_accuracies()`), and shot type frequency (`graph_classified_shots()`). 

### Shortcomings and Limitations


#### Limitation 1: The Functions

While our customized functions do work well for the purposes we outlined, they are limited by who the focus player is. If the focus player has a unique last name, then it is easy to obtain the necessary plot data. However, if the focus player has a common last name (i.e "Thompson" works for Klay Thompson of Golden State Warriors and Tristan Thompson of the Cleveland Cavaliers), then getting the plot data becomes a problematic issue. This case is exacerbated when realizing that players can be traded to multiple teams over the course of a season and over the course of seasons. 

#### Limitation 2: Data Size

The plots themselves are too simplistic given the data size. We dealt with 700K+ shot observations. In order to cleanly see these shots, we opted to introduce these functions and showcase the shot charts in a simple scatter plot. However, given that a player shoots thousands of shots over their career, the plots are limited in visualizing true density. They excel in showing exact shot location, but fail to show how often the player takes a shot for small locations. 

#### Limitation 3: Seasons

The data spans merely seven seasons. It is hard to make claims about true game change given that the time scope is comparatively small. 

### Alternate Approaches


#### Alternate Approach 1: Divide the Court

One alternate approach would be to further divide the court ($C$) into smaller subregions and classify each shot respective to those regions. The coordinates are already there in `c.x` and `c.y`, so such geometric classifications are completely possible. Doing so would provide extra granularity and context to our provided shot plots. 

#### Alternate Approach 2: Hexagons over Dots

One may also consider rewriting the plot code to display hexagonal-bin plots over pure scatterplots. This method can allow to graph the hexagon size by the frequency of the shots taken within the hexagon bin, and also color by shot accuracy to give a sense of how hot that particular hexagonal area is for any league player. 

#### Alternate Approach 3: Player Specifics

To go along with [Limitation 1: The Functions], it may be worthwhile to combine this dataset (`final_shots_data`) with another data set to provide more information on who exactly the player is. Attributes like the team the player is on and the position the player plays can help to appropriately compare shot data to the right counterparts. For instance, it would not be fair to compare Clint Capela to Steph Curry. Both play different positions and different offensive styles. Clint Capela lives and dies in the paint while Steph Curry primarily enjoys the three pointer with the occasional interior basket. However, if Clint Capela is compared to Dwight Howard while Steph Curry is compared to Chris Paul, then more meaningful interpretations on shot quality can be made by adjusting our functions to account for these player attributes. 


 
### Potential Future Directions

While the data set may be small time-wise, the amount of analysis capable with this dataset is tremendously large. One can define a function to graph heat-maps of player shots. One can define a function to graph the player heat zones with respect to the league averages. One may also define a set of probabilities for each region based on the player taking the shot. 

Similarly, there is a huge potential for this report to have an application interface that allows users to type in a player and retrieve all of these graphs at once. 

# References
